<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[matplotlib 初体验]]></title>
      <url>%2F2017%2F02%2F26%2Fmatplotlib-%E5%88%9D%E4%BD%93%E9%AA%8C%2F</url>
      <content type="text"><![CDATA[——愿你不惧荒唐，敢爱如初 从需求出发，第一次体验matplotlib模块。 需求描述为每位玩家生成一张图表，反映其在过去一周游戏货币来源途径的占比，以及其与人工预设的上一阶层的来源对比情况。效果如下： 生成简单的条形图参考文档内容：barchart_demo.py代码已经很接近需求，稍微修改一下，设置了不透明度参数、使用中文标注和稍微修改了一下颜色。实现效果： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647# -*- coding:utf-8 -*-import numpy as npimport matplotlib.pyplot as pltN = 5yoursdata = (20, 35, 30, 35, 27)men_std = (2, 3, 4, 1, 2)ind = np.arange(N) # the x locations for the groupswidth = 0.35 # the width of the barsopacity = 0.4 # 不透明级别fig, ax = plt.subplots()rects1 = ax.bar(ind, yoursdata, width, color='b', alpha=opacity, yerr=men_std)target_data = (25, 32, 34, 20, 25)women_std = (3, 5, 2, 3, 3)rects2 = ax.bar(ind + width, target_data, width, color='r', alpha=opacity, yerr=women_std)# add some text for labels, title and axes ticksax.set_ylabel(u'数量(单位：万)')ax.set_title(u'金币周获得量对比图')ax.set_xticks(ind + width)ax.set_xticklabels(('way1', 'way2', 'way3', 'way4', 'way5'))ax.legend((rects1[0], rects2[0]), (u'您', u'对比群体'))def autolabel(rects): """ Attach a text label above each bar displaying its height """ for rect in rects: height = rect.get_height() ax.text(rect.get_x() + rect.get_width()/2., 1.05*height, '%d' % int(height), ha='center', va='bottom')autolabel(rects1)autolabel(rects2)plt.show() 对于ax.legend()的设置，也可以直接在ax.bar创建是赋以参数label,然后调用ax.legend()即可，不用再次传入参数： 12345rects1 = ax1.bar(index, yoursdata, bar_width, alpha=opacity, color='b', label=u'您')ax1.legend() matplotlib默认不支持在label等参数中传入中文，这里有三种解决办法，笔者直接尝试了第三种方法，成功解决问题 生成简单的饼形图(同理，比较简单，不赘述。)参考文档内容：pie_demo_features.py 两张图合并成一张参考文档内容：subplots_demo.py 只需要创建两个subplot，分别绘制bar和pie即可，以下三种创建subplot的写法效果一致。到这里，基本上已经完成了整个思路，最后可能需要通过plt.figure()对象的一些参数调节整个图的呈现效果，细节不详述。 1234567891011121314151617181920212223242526x = np.linspace(0, 2 * np.pi, 400)y = np.sin(x ** 2)plt.close('all')# Two subplots, the axes array is 1-df, axarr = plt.subplots(2, sharex=True)axarr[0].plot(x, y)axarr[0].set_title('Sharing X axis')axarr[1].scatter(x, y)# Two subplots, unpack the axes array immediatelyf, (ax1, ax2) = plt.subplots(2, 1, sharex=True) # 两行一列ax1.plot(x, y)ax1.set_title('Sharing X axis')ax2.scatter(x, y)# Two subplots, unpack the axes array immediatelyfig = plt.figure()ax1 = fig.add_subplot(211) # 两行一列第一个ax2 = fig.add_subplot(212) # 两行一列第二个ax1.plot(x, y)ax1.set_title('Sharing X axis')ax2.scatter(x, y)plt.show() 保存图片plt.show()只展示绘图界面，无法实现保存，保存命令需要用到fig.savefig()和fig.close(),在循环中调用时，如果不使用fig.close()，其效果是在上一张图的基础上继续作图。 最后，读取数据文件，循环生成图片即可，这里我使用json格式存储数据，结构如下： 1234567891011&#123;"role_id2":&#123;"selfget_top5":&#123;"way1":10,"way2":14,"way3":12,"way4":7,"way5":3&#125;,"cha_self_top5":&#123;"wayA":15,"wayB":13,"wayC":12,"wayD":7,"wayE":6&#125;,"cha_target_top5":&#123;"wayA":19,"wayB":17,"wayC":14,"wayD":8,"wayE":7&#125;&#125;,"role_id1":&#123;"selfget_top5":&#123;"way1":15,"way2":13,"way3":12,"way4":7,"way5":3&#125;,"cha_self_top5":&#123;"wayA":15,"wayB":13,"wayC":12,"wayD":7,"wayE":7&#125;,"cha_target_top5":&#123;"wayA":19,"wayB":17,"wayC":14,"wayD":8,"wayE":7&#125;&#125;&#125; 最后，未经优化，基本满足需求的脚本： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899# -*- coding:utf-8 -*-"""Bar chart demo with pairs of bars grouped for easy comparison."""import numpy as npimport jsonimport codecsimport matplotlib.pyplot as pltdef get_explode(selfdata): explode = [0, 0, 0, 0, 0] a = selfdata.index(max(selfdata)) explode.pop(a) explode.insert(a, 0.1) return explodedef autolabel(rects, ax): """ Attach a text label above each bar displaying its height """ for rect in rects: height = rect.get_height() ax.text(rect.get_x() + rect.get_width() / 2., 1.05 * height, '%d' % int(height), ha='center', va='bottom')def jinbiduibitu(filename, selfdata, selftujing, yoursdata, targetdata, tujinglist, explode): N = 5 labels = selftujing sizes = selfdata men_std = (2, 3, 4, 1, 2) ind = np.arange(N) # the x locations for the groups width = 0.35 # the width of the bars opacity = 0.4 # 不透明度 fig = plt.figure() ax1 = fig.add_subplot(211) ax2 = fig.add_subplot(212) rects1 = ax1.bar(ind, yoursdata, width, color='b', alpha=opacity, yerr=men_std) women_std = (2, 3, 4, 1, 2) rects2 = ax1.bar(ind + width, targetdata, width, color='r', alpha=opacity, yerr=women_std) # add some text for labels, title and axes ticks ax1.set_ylabel(u'数量(单位：万)') ax1.set_title(u'金币周获得量对比图') ax1.set_xticks(ind + width) ax1.set_xticklabels(tujinglist) autolabel(rects1, ax1) autolabel(rects2, ax1) ax1.legend((rects1[0], rects2[0]), (u'您', u'对比群体')) piecs = ['red', 'yellow', 'Maroon', 'blue', 'Orange'] ax2.pie(sizes, colors=piecs, explode=explode, labels=labels, autopct='%1.2f%%', shadow=True, startangle=90) ax2.axis('equal') # Equal aspect ratio ensures that pie is drawn as a circle. ax2.set_title(u'个人金币周获得量渠道占比图', x=0.5,y=1.1) fn = './barchart_demo_output/' + filename + '.png' fig.subplots_adjust(left=None, bottom=None, right=None, top=None, wspace=None, hspace=0.4) # 调整图间距 #plt.show() plt.savefig(fn) plt.close()if __name__ == '__main__': with codecs.open('barchart_demo_input.txt', 'r', encoding = 'utf-8', errors = 'ignore') as f: d = json.load(f) print len(d) for i in d.keys(): filename = i tujinglist = d[i]['cha_self_top5'].keys() selfdata = [] selftujing = d[i]['selfget_top5'].keys() for k in selftujing: sg = d[i]['selfget_top5'][k] selfdata.append(sg) yoursdata = [] targetdata = [] for j in tujinglist: yd = d[i]['cha_self_top5'][j] td = d[i]['cha_target_top5'][j] yoursdata.append(yd) targetdata.append(td) explode = get_explode(selfdata) jinbiduibitu(filename,selfdata, selftujing, yoursdata, targetdata, tujinglist, explode)]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[业务理解能力？]]></title>
      <url>%2F2017%2F02%2F21%2F%E4%B8%9A%E5%8A%A1%E7%90%86%E8%A7%A3%E8%83%BD%E5%8A%9B%EF%BC%9F%2F</url>
      <content type="text"><![CDATA[今天一半事出有因，一半懒惰成性，请了一天假，下午睡醒起床的那十几秒，眼前发黑，血糖低得可怕。如题，觉得真的时业务理解能力有所缺陷，或者游戏真的不是我内心喜欢的（但是我喜欢什么呢？），算了吧，提醒我要加快一下脚步…下午手机上下载了一个learn SQL 这个系列好像还做的不错，于是直接就看完了这个教程，比较简单，还拿到了下面这个东东！（并没有什么用，还不如去看lxw）]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[python多进程与多线程]]></title>
      <url>%2F2017%2F02%2F12%2Fpython%E5%A4%9A%E8%BF%9B%E7%A8%8B%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B%2F</url>
      <content type="text"><![CDATA[——五花马,千金裘,呼儿将出换美酒,与尔同销万古愁。 越来越觉得自己对这些东西一知半解…折腾了好久，今天整理一下我一知半解的 python多进程与多线程 毕竟每周还是应该多少有点什么值得记下来… 首先理解：进程&gt;线程（不知道可不可以这样讲），进程里至少有一个线程，线程之间共享内存空间，有其他进程占用内存空间时，需要等待内存闲置。一篇文章：关于进程和线程区别的类比：http://www.ruanyifeng.com/blog/2013/04/processes_and_threads.html 多进程1.创建多进程的：使用multiprocessing模块的Process类 12345678910111213141516from multiprocessing import Processimport osdef test(name): # os模块的getpid()方法可以获取当前进程的进程id print 'Run process %s (%s)...' % (name, os.getpid())if __name__ == '__main__': print 'Main process %s.' % os.getpid() # 创建一个进程 p = Process(target=test, args=('process1',)) p.start() # 调用start()方法，开始执行子进程 p.join() # 调用进程的join()方法，来阻塞除当前进程以外的所有进程,相当于是上锁的操作 print 'test finished!' 2.依次创建进程进行一次计算并测试效率 123456789101112131415161718192021222324252627282930313233from multiprocessing import Processimport timedef test(num): sum = 0 for i in range(0, num): sum += i return sumif __name__ == '__main__': start_time = time.time() test(10000000) test(10000000) test(10000000) last_time = time.time() - start_time print last_time # 常规写法，耗时2.85500001907s p1 = Process(target=test, args=(10000000,)) p2 = Process(target=test, args=(10000000,)) p3 = Process(target=test, args=(10000000,)) p1.start() p2.start() p3.start() p1.join() p2.join() p3.join() # 多进程写法，耗时1.36999988556s 这里开启进程时要注意一点：先把所有.start()写完，再写.join(),这样发生进程阻塞的情况要少，这样就能充分发挥利用cpu，提高执行效率。 3.使用进程池的方式创建进程 12345678910111213141516171819202122232425262728from multiprocessing import Poolimport timedef test(num): sum = 0 for i in range(0, num): sum += i return sumdef test_test(num): a = test(num) b = test(num) c = test(num) return a+b+cif __name__ == '__main__': start_time = time.time() pool = Pool(processes=3) result = pool.apply_async(test_test, args=(10000000,)) pool.close() pool.join() print result.get() # 如果不获取结果，效率会高很多 last_time = time.time() - start_time print last_time# 耗时：3.21100020409s 注意两点： 调用join之前，先调用close函数，否则会出错。执行完close后不会有新的进程加入到pool。 apply和apply_async的区别：apply主进程会阻塞于函数，主进程的执行流程同单进程一样；apply_async是非阻塞的且支持结果返回后进行回调，主进程循环运行过程中不等待apply_async的返回结果，在主进程结束后，即使子进程还未返回整个程序也会退出。虽然apply_async是非阻塞的，但其返回结果的get方法却是阻塞的，如使用result.get()会阻塞主进程。对返回结果不感兴趣， 那么可以在主进程中使用pool.close与pool.join来防止主进程退出。注意join方法一定要在close或terminate之后调用。 Pool相关函数：https://docs.python.org/2/library/multiprocessing.html#module-multiprocessing.pool 4.使用Pool的map方法，进行多进程（cpu密集型任务）操作伪代码 1234567891011121314from multiprocessing import Pooldef method1(): return 被处理元素列表def method2(): 进行处理的方法if __name__ == '__mian__': pool = Pool() pool.map(method2, method1的结果) pool.close() pool.join() 多线程多线程适用于io密集型的任务，暂时只记使用multiprocessing.dummy这一种实现方法 12345678910111213141516171819202122232425262728import urllib2 from multiprocessing.dummy import Pool as ThreadPool urls = [ 'http://www.python.org', 'http://www.python.org/about/', 'http://www.onlamp.com/pub/a/python/2003/04/17/metaclasses.html', 'http://www.python.org/doc/', 'http://www.python.org/download/', 'http://www.python.org/getit/', 'http://www.python.org/community/', 'https://wiki.python.org/moin/', 'http://planet.python.org/', 'https://wiki.python.org/moin/LocalUserGroups', 'http://www.python.org/psf/', 'http://docs.python.org/devguide/', 'http://www.python.org/community/awards/' # etc.. ]# Make the Pool of workerspool = ThreadPool(4) # Open the urls in their own threads# and return the resultsresults = pool.map(urllib2.urlopen, urls)#close the pool and wait for the work to finish pool.close() pool.join() 总结几句： IO 密集型任务选择multiprocessing.dummy，CPU 密集型任务选择multiprocessing 关于IO 密集型和CPU 密集型：所谓IO密集型任务，是指磁盘IO、网络IO占主要的任务，计算量很小。比如请求网页、读写文件等。所谓计算密集型任务，是指CPU计算占主要的任务，CPU一直处于满负荷状态。比如在一个很大的列表中查找元素，复杂的加减乘除等。 文章参考： 一行 Python 实现并行化 – 日常多线程操作的新思路 python 中多进程以及多线程编程的总结 ——写的过程中还看到了进程之间的通信与同时操作一个文件的进程锁的相关内容，只能慢慢来咯…]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[python collections]]></title>
      <url>%2F2017%2F01%2F08%2Fpython-collections%2F</url>
      <content type="text"><![CDATA[具体实现方法参考文档：https://docs.python.org/3/library/collections.html container datetypes abstract Cool deque 双端序列 有得必有失 Counter 统计hashable objects 类似sql中的sum(A)…group by id OrderedDict 顺序存取的字典 None defaultdict key不存在时，赋予value默认值 实时统计玩家参与某副本的次数 namedtuple() 使tuple内的元素有自己的名称 坐标（x，y） 还有一些其他的类如ChainMap，暂时未归纳 defaultdict这个类想到的一些东西 在实时获取玩家参与某个玩家的次数时，由于玩家id唯一，一般作为key，使用dict比较方便，还可以应用json （听说有另外一个ujson更好用，慢慢看吧）格式进行交互，但是一开始没有进入统计范围的玩家，获取key时会报错，使用defaultdict可以解决这个问题 1234567891011# 普通字典In [7]: d = &#123;&#125;In [8]: d['a']---------------------------------------------------------------------------KeyError Traceback (most recent call last)&lt;ipython-input-8-169a40407b7f&gt; in &lt;module&gt;()----&gt; 1 d['a']KeyError: 'a' 1234567# defaultdictIn [4]: from collections import defaultdictIn [5]: d = defaultdict(int)In [6]: d['a']Out[6]: 0 实现hive中collect_all() 函数的函数,本来想在sqlite3上实现一下，但貌似不支持这个方法。 color count yellow 1 blue 2 yellow 3 blue 4 red 1 hive sql：1select color, collect_list(count) from test group by color difaultdict：12345678910In [19]: s = [('yellow', 1), ('blue', 2), ('yellow', 3), ('blue', 4), ('red', 1)]In [20]: d = defaultdict(list)In [21]: for k, v in s: ...: d[k].append(v) ...:In [22]: dOut[22]: defaultdict(list, &#123;'blue': [2, 4], 'red': [1], 'yellow': [1, 3]&#125;) 图床抽风用不了截图，就凑合着，中午没吃饭，又困又饿…]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[openpyxl操作excel文件]]></title>
      <url>%2F2016%2F12%2F31%2Fopenpyxl%E6%93%8D%E4%BD%9Cexcel%E6%96%87%E4%BB%B6%20%2F</url>
      <content type="text"><![CDATA[这个完全是为了熟悉hexo和markdown语法，上周末生日，来自一位朋友的工作需求 需求描述需要将目录中的每一行数据分别建立单独的工作表，应用工作表1的模板，并填入对于应的数据（红色框部分） 实现效果： 实现过程第一步：批量生成指定名称的工作表，excel可直接操作 选中“桥梁名称”列，先Alt+D，再Alt+P，插入数据透视表 在数据透视表字段，将“桥梁名称”拖拽到筛选区域 透视表“选项”，选择“显示报表筛选页”，确定 参考：http://jingyan.baidu.com/article/6fb756ec8c6703241858fbba.html 第二步：复制模板到各个工作表这里只需要复制模板，全选模板内容，按住shift全选工作表，Ctrl+V复制即可 第三步：填入数据这应该是可以直接用excel完成的，比较菜，不会，选择了python openpyxl 模块操作excel的方式参考openpyxl文档：http://openpyxl.readthedocs.io/en/default/usage.html 12345678910111213141516171819202122232425262728293031323334353637383940414243444546# -*- coding:utf-8 -*-from openpyxl import load_workbookwb = load_workbook(filename = u"xxx.xlsx")ws1 = wb.get_sheet_by_name(wb.get_sheet_names()[-2])print ws1.titlehangshu = ws1.get_highest_row()content = &#123;&#125;def get_content(): for i in range(2,217): if i &lt; 11: key = '00' + str(i-1) elif i &lt; 101: key = '0' + str(i-1) else: key = str(i-1) name_index = 'C' + str(i) bianhao_index = 'B' + str(i) dengji_index = 'H' + str(i) xunhao_index = 'K' + str(i) name = ws1[name_index].value keyname = key + name bianhao = ws1[bianhao_index].value dengji = ws1[dengji_index].value xunhao = ws1[xunhao_index].value content[keyname] = [bianhao, dengji, xunhao, name] return contentcontent = get_content()ll = 0for j in wb.get_sheet_names(): print j print content[j][3] wb.get_sheet_by_name(j)['B3'] = content[j][3] wb.get_sheet_by_name(j)['D3'] = content[j][0] wb.get_sheet_by_name(j)['F3'] = content[j][1] wb.get_sheet_by_name(j)['F26'] = content[j][2] ll += 1 if ll &gt; 214: break wb.save(filename = 'aaa_test1.xlsx')]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[hello-world]]></title>
      <url>%2F2016%2F12%2F24%2Fhello-world%2F</url>
      <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
    </entry>

    
  
  
</search>
